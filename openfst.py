# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

"""
Python Bindings for the OpenFST Library
"""

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openfst', [dirname(__file__)])
        except ImportError:
            import _openfst
            return _openfst
        if fp is not None:
            try:
                _mod = imp.load_module('_openfst', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openfst = swig_import_helper()
    del swig_import_helper
else:
    import _openfst
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openfst.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _openfst.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _openfst.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _openfst.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _openfst.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _openfst.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _openfst.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _openfst.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _openfst.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _openfst.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _openfst.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _openfst.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _openfst.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _openfst.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _openfst.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _openfst.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _openfst.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _openfst.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class FloatVector(_object):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _openfst.FloatVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _openfst.FloatVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _openfst.FloatVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _openfst.FloatVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _openfst.FloatVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> FloatVector"""
        return _openfst.FloatVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, FloatVector v)"""
        return _openfst.FloatVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _openfst.FloatVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _openfst.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> FloatVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _openfst.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, FloatVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _openfst.FloatVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _openfst.FloatVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _openfst.FloatVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _openfst.FloatVector_size(self)

    def clear(self):
        """clear(self)"""
        return _openfst.FloatVector_clear(self)

    def swap(self, *args):
        """swap(self, FloatVector v)"""
        return _openfst.FloatVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _openfst.FloatVector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _openfst.FloatVector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _openfst.FloatVector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _openfst.FloatVector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _openfst.FloatVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _openfst.FloatVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _openfst.FloatVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> FloatVector
        __init__(self, FloatVector arg0) -> FloatVector
        __init__(self, size_type size) -> FloatVector
        __init__(self, size_type size, value_type value) -> FloatVector
        """
        this = _openfst.new_FloatVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _openfst.FloatVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _openfst.FloatVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _openfst.FloatVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _openfst.FloatVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _openfst.FloatVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _openfst.FloatVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _openfst.FloatVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _openfst.FloatVector_capacity(self)

    __swig_destroy__ = _openfst.delete_FloatVector
    __del__ = lambda self : None;
FloatVector_swigregister = _openfst.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class IntVector(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _openfst.IntVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _openfst.IntVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _openfst.IntVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _openfst.IntVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _openfst.IntVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> IntVector"""
        return _openfst.IntVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, IntVector v)"""
        return _openfst.IntVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _openfst.IntVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _openfst.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> IntVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _openfst.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, IntVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _openfst.IntVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _openfst.IntVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _openfst.IntVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _openfst.IntVector_size(self)

    def clear(self):
        """clear(self)"""
        return _openfst.IntVector_clear(self)

    def swap(self, *args):
        """swap(self, IntVector v)"""
        return _openfst.IntVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _openfst.IntVector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _openfst.IntVector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _openfst.IntVector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _openfst.IntVector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _openfst.IntVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _openfst.IntVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _openfst.IntVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, IntVector arg0) -> IntVector
        __init__(self, size_type size) -> IntVector
        __init__(self, size_type size, value_type value) -> IntVector
        """
        this = _openfst.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _openfst.IntVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _openfst.IntVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _openfst.IntVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _openfst.IntVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _openfst.IntVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _openfst.IntVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _openfst.IntVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _openfst.IntVector_capacity(self)

    __swig_destroy__ = _openfst.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _openfst.IntVector_swigregister
IntVector_swigregister(IntVector)

class LongLongVector(_object):
    """Proxy of C++ std::vector<(long long)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongLongVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LongLongVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _openfst.LongLongVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _openfst.LongLongVector___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _openfst.LongLongVector___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _openfst.LongLongVector___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _openfst.LongLongVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> LongLongVector"""
        return _openfst.LongLongVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, LongLongVector v)"""
        return _openfst.LongLongVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _openfst.LongLongVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _openfst.LongLongVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> LongLongVector
        __getitem__(self, difference_type i) -> value_type
        """
        return _openfst.LongLongVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, LongLongVector v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _openfst.LongLongVector___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _openfst.LongLongVector_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _openfst.LongLongVector_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _openfst.LongLongVector_size(self)

    def clear(self):
        """clear(self)"""
        return _openfst.LongLongVector_clear(self)

    def swap(self, *args):
        """swap(self, LongLongVector v)"""
        return _openfst.LongLongVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _openfst.LongLongVector_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _openfst.LongLongVector_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _openfst.LongLongVector_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _openfst.LongLongVector_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _openfst.LongLongVector_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _openfst.LongLongVector_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _openfst.LongLongVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> LongLongVector
        __init__(self, LongLongVector arg0) -> LongLongVector
        __init__(self, size_type size) -> LongLongVector
        __init__(self, size_type size, value_type value) -> LongLongVector
        """
        this = _openfst.new_LongLongVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _openfst.LongLongVector_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _openfst.LongLongVector_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _openfst.LongLongVector_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _openfst.LongLongVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _openfst.LongLongVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _openfst.LongLongVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _openfst.LongLongVector_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _openfst.LongLongVector_capacity(self)

    __swig_destroy__ = _openfst.delete_LongLongVector
    __del__ = lambda self : None;
LongLongVector_swigregister = _openfst.LongLongVector_swigregister
LongLongVector_swigregister(LongLongVector)

MATCH_INPUT = _openfst.MATCH_INPUT
MATCH_OUTPUT = _openfst.MATCH_OUTPUT
MATCH_BOTH = _openfst.MATCH_BOTH
MATCH_NONE = _openfst.MATCH_NONE
MATCH_UNKNOWN = _openfst.MATCH_UNKNOWN

def ComplementProperties(*args):
  """ComplementProperties(uint64 inprops) -> uint64"""
  return _openfst.ComplementProperties(*args)

def ComposeProperties(*args):
  """ComposeProperties(uint64 inprops1, uint64 inprops2) -> uint64"""
  return _openfst.ComposeProperties(*args)

def DeterminizeProperties(*args):
  """DeterminizeProperties(uint64 inprops, bool has_subsequential_label) -> uint64"""
  return _openfst.DeterminizeProperties(*args)

def FactorWeightProperties(*args):
  """FactorWeightProperties(uint64 inprops) -> uint64"""
  return _openfst.FactorWeightProperties(*args)

def InvertProperties(*args):
  """InvertProperties(uint64 inprops) -> uint64"""
  return _openfst.InvertProperties(*args)

def ProjectProperties(*args):
  """ProjectProperties(uint64 inprops, bool project_input) -> uint64"""
  return _openfst.ProjectProperties(*args)

def RelabelProperties(*args):
  """RelabelProperties(uint64 inprops) -> uint64"""
  return _openfst.RelabelProperties(*args)

def ReplaceProperties(*args):
  """
    ReplaceProperties(vector<(uint64)> inprops, ssize_t root, bool epsilon_on_replace, 
        bool no_empty_fst) -> uint64
    """
  return _openfst.ReplaceProperties(*args)

def ReverseProperties(*args):
  """ReverseProperties(uint64 inprops) -> uint64"""
  return _openfst.ReverseProperties(*args)

def ReweightProperties(*args):
  """ReweightProperties(uint64 inprops) -> uint64"""
  return _openfst.ReweightProperties(*args)

def SynchronizeProperties(*args):
  """SynchronizeProperties(uint64 inprops) -> uint64"""
  return _openfst.SynchronizeProperties(*args)

def PropertyBitName(*args):
  """PropertyBitName(int bit) -> char"""
  return _openfst.PropertyBitName(*args)
MATCHER_REWRITE_AUTO = _openfst.MATCHER_REWRITE_AUTO
MATCHER_REWRITE_ALWAYS = _openfst.MATCHER_REWRITE_ALWAYS
MATCHER_REWRITE_NEVER = _openfst.MATCHER_REWRITE_NEVER
class Weight(_object):
    """Standard weight class, using floating-point values in the tropical semiring."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Weight, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Weight, name)
    __repr__ = _swig_repr
    def Value(self):
        """
        Value(self) -> float

        Get the floating-point value of a weight.
        """
        return _openfst.Weight_Value(self)

    def Zero():
        """
        Zero() -> Weight

        Returns the zero weight for this semiring.  This is the weight which
        acts as an annihilator for multiplication and an identity for addition.
        For the standard weight class, its value is positive infinity.
        """
        return _openfst.Weight_Zero()

    if _newclass:Zero = staticmethod(Zero)
    __swig_getmethods__["Zero"] = lambda x: Zero
    def One():
        """
        One() -> Weight

        Returns the one value for this semiring.  This is the weight which
        acts as an identity for multiplication.
        For the standard weight class, its value is zero.
        """
        return _openfst.Weight_One()

    if _newclass:One = staticmethod(One)
    __swig_getmethods__["One"] = lambda x: One
    def __init__(self): 
        """__init__(self) -> Weight"""
        this = _openfst.new_Weight()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_Weight
    __del__ = lambda self : None;
Weight_swigregister = _openfst.Weight_swigregister
Weight_swigregister(Weight)
cvar = _openfst.cvar
epsilon = cvar.epsilon
kNoLabel = cvar.kNoLabel
kExpanded = cvar.kExpanded
kMutable = cvar.kMutable
kAcceptor = cvar.kAcceptor
kNotAcceptor = cvar.kNotAcceptor
kIDeterministic = cvar.kIDeterministic
kNonIDeterministic = cvar.kNonIDeterministic
kODeterministic = cvar.kODeterministic
kNonODeterministic = cvar.kNonODeterministic
kEpsilons = cvar.kEpsilons
kNoEpsilons = cvar.kNoEpsilons
kIEpsilons = cvar.kIEpsilons
kNoIEpsilons = cvar.kNoIEpsilons
kOEpsilons = cvar.kOEpsilons
kNoOEpsilons = cvar.kNoOEpsilons
kILabelSorted = cvar.kILabelSorted
kNotILabelSorted = cvar.kNotILabelSorted
kOLabelSorted = cvar.kOLabelSorted
kNotOLabelSorted = cvar.kNotOLabelSorted
kWeighted = cvar.kWeighted
kUnweighted = cvar.kUnweighted
kCyclic = cvar.kCyclic
kAcyclic = cvar.kAcyclic
kInitialCyclic = cvar.kInitialCyclic
kInitialAcyclic = cvar.kInitialAcyclic
kTopSorted = cvar.kTopSorted
kNotTopSorted = cvar.kNotTopSorted
kAccessible = cvar.kAccessible
kNotAccessible = cvar.kNotAccessible
kCoAccessible = cvar.kCoAccessible
kNotCoAccessible = cvar.kNotCoAccessible
kString = cvar.kString
kNotString = cvar.kNotString
kNullProperties = cvar.kNullProperties
kCopyProperties = cvar.kCopyProperties
kSetStartProperties = cvar.kSetStartProperties
kSetFinalProperties = cvar.kSetFinalProperties
kAddStateProperties = cvar.kAddStateProperties
kAddArcProperties = cvar.kAddArcProperties
kSetArcProperties = cvar.kSetArcProperties
kDeleteStatesProperties = cvar.kDeleteStatesProperties
kDeleteArcsProperties = cvar.kDeleteArcsProperties
kStateSortProperties = cvar.kStateSortProperties
kArcSortProperties = cvar.kArcSortProperties
kILabelInvariantProperties = cvar.kILabelInvariantProperties
kOLabelInvariantProperties = cvar.kOLabelInvariantProperties
kWeightInvariantProperties = cvar.kWeightInvariantProperties
kAddSuperFinalProperties = cvar.kAddSuperFinalProperties
kRmSuperFinalProperties = cvar.kRmSuperFinalProperties
kBinaryProperties = cvar.kBinaryProperties
kTrinaryProperties = cvar.kTrinaryProperties
kPosTrinaryProperties = cvar.kPosTrinaryProperties
kNegTrinaryProperties = cvar.kNegTrinaryProperties
kFstProperties = cvar.kFstProperties

def ClosureProperties(*args):
  """
    ClosureProperties(uint64 inprops, bool star, bool delayed = False) -> uint64
    ClosureProperties(uint64 inprops, bool star) -> uint64
    """
  return _openfst.ClosureProperties(*args)

def ConcatProperties(*args):
  """
    ConcatProperties(uint64 inprops1, uint64 inprops2, bool delayed = False) -> uint64
    ConcatProperties(uint64 inprops1, uint64 inprops2) -> uint64
    """
  return _openfst.ConcatProperties(*args)

def RmEpsilonProperties(*args):
  """
    RmEpsilonProperties(uint64 inprops, bool delayed = False) -> uint64
    RmEpsilonProperties(uint64 inprops) -> uint64
    """
  return _openfst.RmEpsilonProperties(*args)

def UnionProperties(*args):
  """
    UnionProperties(uint64 inprops1, uint64 inprops2, bool delayed = False) -> uint64
    UnionProperties(uint64 inprops1, uint64 inprops2) -> uint64
    """
  return _openfst.UnionProperties(*args)

def Weight_Zero():
  """
    Weight_Zero() -> Weight

    Returns the zero weight for this semiring.  This is the weight which
    acts as an annihilator for multiplication and an identity for addition.
    For the standard weight class, its value is positive infinity.
    """
  return _openfst.Weight_Zero()

def Weight_One():
  """
    Weight_One() -> Weight

    Returns the one value for this semiring.  This is the weight which
    acts as an identity for multiplication.
    For the standard weight class, its value is zero.
    """
  return _openfst.Weight_One()

class LogWeight(_object):
    """Standard weight class, using floating-point values in the log semiring."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogWeight, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogWeight, name)
    __repr__ = _swig_repr
    def Value(self):
        """
        Value(self) -> float

        Get the floating-point value of a weight.
        """
        return _openfst.LogWeight_Value(self)

    def Zero():
        """
        Zero() -> LogWeight

        Returns the zero weight for this semiring.  This is the weight which
        acts as an annihilator for multiplication and an identity for addition.
        For the standard weight class, its value is positive infinity.
        """
        return _openfst.LogWeight_Zero()

    if _newclass:Zero = staticmethod(Zero)
    __swig_getmethods__["Zero"] = lambda x: Zero
    def One():
        """
        One() -> LogWeight

        Returns the one value for this semiring.  This is the weight which
        acts as an identity for multiplication.
        For the standard weight class, its value is zero.
        """
        return _openfst.LogWeight_One()

    if _newclass:One = staticmethod(One)
    __swig_getmethods__["One"] = lambda x: One
    def __init__(self): 
        """__init__(self) -> LogWeight"""
        this = _openfst.new_LogWeight()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogWeight
    __del__ = lambda self : None;
LogWeight_swigregister = _openfst.LogWeight_swigregister
LogWeight_swigregister(LogWeight)

def LogWeight_Zero():
  """
    LogWeight_Zero() -> LogWeight

    Returns the zero weight for this semiring.  This is the weight which
    acts as an annihilator for multiplication and an identity for addition.
    For the standard weight class, its value is positive infinity.
    """
  return _openfst.LogWeight_Zero()

def LogWeight_One():
  """
    LogWeight_One() -> LogWeight

    Returns the one value for this semiring.  This is the weight which
    acts as an identity for multiplication.
    For the standard weight class, its value is zero.
    """
  return _openfst.LogWeight_One()

class SymbolTable(_object):
    """Symbol table class, map input/output symbol IDs to and from strings."""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymbolTable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SymbolTable, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, string name) -> SymbolTable

        Create a new symbol table with identifying name.
        """
        this = _openfst.new_SymbolTable(*args)
        try: self.this.append(this)
        except: self.this = this
    def AddSymbol(self, *args):
        """
        AddSymbol(self, string name, long long id) -> long long
        AddSymbol(self, string name) -> long long

        Add a symbol to the symbol table, optionally with a specific
        numeric ID.  Returns the numeric ID assigned to this symbol (which may
        already exist).
        """
        return _openfst.SymbolTable_AddSymbol(self, *args)

    def AddTable(self, *args):
        """
        AddTable(self, SymbolTable symtab)

        Merge the contents of another symbol table into this one.
        """
        return _openfst.SymbolTable_AddTable(self, *args)

    def Name(self):
        """
        Name(self) -> string

        Returns the identifying name of this symbol table.
        """
        return _openfst.SymbolTable_Name(self)

    def CheckSum(self):
        """
        CheckSum(self) -> string

        Returns the identifying name of this symbol table.
        """
        return _openfst.SymbolTable_CheckSum(self)

    def Copy(self):
        """
        Copy(self) -> SymbolTable

        Return a copy of this symbol table.
        """
        return _openfst.SymbolTable_Copy(self)

    def ReadText(*args):
        """
        ReadText(string filename, bool allow_negative = False) -> SymbolTable
        ReadText(string filename) -> SymbolTable

        Read entries from a text file.
        """
        return _openfst.SymbolTable_ReadText(*args)

    if _newclass:ReadText = staticmethod(ReadText)
    __swig_getmethods__["ReadText"] = lambda x: ReadText
    def WriteText(self, *args):
        """
        WriteText(self, string filename) -> bool

        Write entries to a text file.
        """
        return _openfst.SymbolTable_WriteText(self, *args)

    def Read(*args):
        """
        Read(string filename) -> SymbolTable

        Read entries from a binary file.
        """
        return _openfst.SymbolTable_Read(*args)

    if _newclass:Read = staticmethod(Read)
    __swig_getmethods__["Read"] = lambda x: Read
    def Write(self, *args):
        """
        Write(self, string filename) -> bool

        Write entries to a binary file.
        """
        return _openfst.SymbolTable_Write(self, *args)

    def Find(self, *args):
        """
        Find(self, long long id) -> string
        Find(self, string name) -> long long

        Look up a symbol or numeric ID in the table.  If called with a string,
        returns the ID for that string or -1 if not found.  If called with an
        integer, returns the string for that ID, or the empty string if not found.
        """
        return _openfst.SymbolTable_Find(self, *args)

    def AvailableKey(self):
        """
        AvailableKey(self) -> long long

        Returns the next automatically-assigned symbol ID.
        """
        return _openfst.SymbolTable_AvailableKey(self)

    def NumSymbols(self):
        """
        NumSymbols(self) -> unsigned long

        Returns the number of unique symbols in this table.
        """
        return _openfst.SymbolTable_NumSymbols(self)

    __swig_destroy__ = _openfst.delete_SymbolTable
    __del__ = lambda self : None;
SymbolTable_swigregister = _openfst.SymbolTable_swigregister
SymbolTable_swigregister(SymbolTable)

def SymbolTable_ReadText(*args):
  """
    ReadText(string filename, bool allow_negative = False) -> SymbolTable
    SymbolTable_ReadText(string filename) -> SymbolTable

    Read entries from a text file.
    """
  return _openfst.SymbolTable_ReadText(*args)

def SymbolTable_Read(*args):
  """
    SymbolTable_Read(string filename) -> SymbolTable

    Read entries from a binary file.
    """
  return _openfst.SymbolTable_Read(*args)

class SymbolTableIterator(_object):
    """
    Underlying iterator class over SymbolTable objects.  Use Python iterator
    syntax instead, e.g.:

    for symbol, id in symtab:
        print "symbol %s has id %d" % (symbol, id)

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymbolTableIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SymbolTableIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SymbolTable symtab) -> SymbolTableIterator

        Underlying iterator class over SymbolTable objects.  Use Python iterator
        syntax instead, e.g.:

        for symbol, id in symtab:
            print "symbol %s has id %d" % (symbol, id)

        """
        this = _openfst.new_SymbolTableIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Done(self):
        """Done(self) -> bool"""
        return _openfst.SymbolTableIterator_Done(self)

    def Symbol(self):
        """Symbol(self) -> string"""
        return _openfst.SymbolTableIterator_Symbol(self)

    def Value(self):
        """Value(self) -> long long"""
        return _openfst.SymbolTableIterator_Value(self)

    def Next(self):
        """Next(self)"""
        return _openfst.SymbolTableIterator_Next(self)

    def Reset(self):
        """Reset(self)"""
        return _openfst.SymbolTableIterator_Reset(self)

    __swig_destroy__ = _openfst.delete_SymbolTableIterator
    __del__ = lambda self : None;
SymbolTableIterator_swigregister = _openfst.SymbolTableIterator_swigregister
SymbolTableIterator_swigregister(SymbolTableIterator)

class IteratorProxy(object):
    "Base class for Pythonic proxies of OpenFst iterators."
    def __init__(self, itor):
        self.first = True
        self.itor = itor

    def __iter__(self):
        return self.__class__(self.itor)

    def get(self):
        "Method to be overriden which returns the iterator's value"
        return self.itor

    def next(self):
        if self.first:
            self.first = False
        else:
            self.itor.Next()
        if self.itor.Done():
            raise StopIteration
        return self.get()

class SymbolTable_iter(IteratorProxy):
    def get(self):
        return self.itor.Symbol(), self.itor.Value()

class Fst_state_iter(IteratorProxy):
    def get(self):
        return self.itor.Value()

class Fst_arc_iter(IteratorProxy):
    def get(self):
        return self.itor.Value()

class Fst_mutable_arc_iter(IteratorProxy):
    pass

class StdArc(_object):
    """Proxy of C++ ArcTpl<(Weight)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdArc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdArc, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ilabel"] = _openfst.StdArc_ilabel_set
    __swig_getmethods__["ilabel"] = _openfst.StdArc_ilabel_get
    if _newclass:ilabel = _swig_property(_openfst.StdArc_ilabel_get, _openfst.StdArc_ilabel_set)
    __swig_setmethods__["olabel"] = _openfst.StdArc_olabel_set
    __swig_getmethods__["olabel"] = _openfst.StdArc_olabel_get
    if _newclass:olabel = _swig_property(_openfst.StdArc_olabel_get, _openfst.StdArc_olabel_set)
    __swig_setmethods__["nextstate"] = _openfst.StdArc_nextstate_set
    __swig_getmethods__["nextstate"] = _openfst.StdArc_nextstate_get
    if _newclass:nextstate = _swig_property(_openfst.StdArc_nextstate_get, _openfst.StdArc_nextstate_set)
    __swig_setmethods__["weight"] = _openfst.StdArc_weight_set
    __swig_getmethods__["weight"] = _openfst.StdArc_weight_get
    if _newclass:weight = _swig_property(_openfst.StdArc_weight_get, _openfst.StdArc_weight_set)
    def __init__(self, *args): 
        """
        __init__(self, int ilabel, int olabel, float weight, int nextstate) -> StdArc

        Create a new arc with specified input and output labels,
        weight, and target state.  Use 0 as the label for epsilon arcs.
        """
        this = _openfst.new_StdArc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdArc
    __del__ = lambda self : None;
StdArc_swigregister = _openfst.StdArc_swigregister
StdArc_swigregister(StdArc)

class LogArc(_object):
    """Proxy of C++ ArcTpl<(LogWeight)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogArc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogArc, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ilabel"] = _openfst.LogArc_ilabel_set
    __swig_getmethods__["ilabel"] = _openfst.LogArc_ilabel_get
    if _newclass:ilabel = _swig_property(_openfst.LogArc_ilabel_get, _openfst.LogArc_ilabel_set)
    __swig_setmethods__["olabel"] = _openfst.LogArc_olabel_set
    __swig_getmethods__["olabel"] = _openfst.LogArc_olabel_get
    if _newclass:olabel = _swig_property(_openfst.LogArc_olabel_get, _openfst.LogArc_olabel_set)
    __swig_setmethods__["nextstate"] = _openfst.LogArc_nextstate_set
    __swig_getmethods__["nextstate"] = _openfst.LogArc_nextstate_get
    if _newclass:nextstate = _swig_property(_openfst.LogArc_nextstate_get, _openfst.LogArc_nextstate_set)
    __swig_setmethods__["weight"] = _openfst.LogArc_weight_set
    __swig_getmethods__["weight"] = _openfst.LogArc_weight_get
    if _newclass:weight = _swig_property(_openfst.LogArc_weight_get, _openfst.LogArc_weight_set)
    def __init__(self, *args): 
        """
        __init__(self, int ilabel, int olabel, float weight, int nextstate) -> LogArc

        Create a new arc with specified input and output labels,
        weight, and target state.  Use 0 as the label for epsilon arcs.
        """
        this = _openfst.new_LogArc(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogArc
    __del__ = lambda self : None;
LogArc_swigregister = _openfst.LogArc_swigregister
LogArc_swigregister(LogArc)

class StdFst(_object):
    """Proxy of C++ Fst<(StdArc)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdFst, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdFst, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(StdStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(StdArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_StdFst
    __del__ = lambda self : None;
StdFst_swigregister = _openfst.StdFst_swigregister
StdFst_swigregister(StdFst)

class LogFst(_object):
    """Proxy of C++ Fst<(LogArc)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogFst, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogFst, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(LogStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(LogArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_LogFst
    __del__ = lambda self : None;
LogFst_swigregister = _openfst.LogFst_swigregister
LogFst_swigregister(LogFst)

class StdMutableFst(StdFst):
    """Proxy of C++ MutableFst<(StdArc)> class"""
    __swig_setmethods__ = {}
    for _s in [StdFst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdMutableFst, name, value)
    __swig_getmethods__ = {}
    for _s in [StdFst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StdMutableFst, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(StdStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(StdArcIterator(self, stateid))

    def mutable_iterarcs(self, stateid):
        """Return a mutable iterator over outgoing arcs from stateid."""
        return Fst_mutable_arc_iter(StdMutableArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_StdMutableFst
    __del__ = lambda self : None;
StdMutableFst_swigregister = _openfst.StdMutableFst_swigregister
StdMutableFst_swigregister(StdMutableFst)

class LogMutableFst(LogFst):
    """Proxy of C++ MutableFst<(LogArc)> class"""
    __swig_setmethods__ = {}
    for _s in [LogFst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogMutableFst, name, value)
    __swig_getmethods__ = {}
    for _s in [LogFst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LogMutableFst, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(LogStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(LogArcIterator(self, stateid))

    def mutable_iterarcs(self, stateid):
        """Return a mutable iterator over outgoing arcs from stateid."""
        return Fst_mutable_arc_iter(LogMutableArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_LogMutableFst
    __del__ = lambda self : None;
LogMutableFst_swigregister = _openfst.LogMutableFst_swigregister
LogMutableFst_swigregister(LogMutableFst)

class StdVectorFst(StdMutableFst):
    """Proxy of C++ VectorFst<(StdArc)> class"""
    __swig_setmethods__ = {}
    for _s in [StdMutableFst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdVectorFst, name, value)
    __swig_getmethods__ = {}
    for _s in [StdMutableFst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StdVectorFst, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> StdVectorFst
        __init__(self, StdFst fst) -> StdVectorFst

        constructor
        """
        this = _openfst.new_StdVectorFst(*args)
        try: self.this.append(this)
        except: self.this = this
    def AddState(self):
        """
        AddState(self) -> int

        Add a new state to this FST.  Returns the ID of this new state.
        """
        return _openfst.StdVectorFst_AddState(self)

    def Start(self):
        """
        Start(self) -> int

        Get the start state ID of this FST.
        """
        return _openfst.StdVectorFst_Start(self)

    def Final(self, *args):
        """
        Final(self, int stateid) -> ArcTpl<(TropicalWeight)>::Weight

        Check if the given state is a final state.  Returns its weight if
        it is final, otherwise returns Weight.Zero() = inf.  Use IsFinal()
        instead if all you are interested in doing is checking for finality.
        """
        return _openfst.StdVectorFst_Final(self, *args)

    def NumStates(self):
        """
        NumStates(self) -> int

        Returns the number of states in this FST.
        """
        return _openfst.StdVectorFst_NumStates(self)

    def NumArcs(self, *args):
        """
        NumArcs(self, int stateid) -> int

        Returns the number of arcs leaving the given state.
        """
        return _openfst.StdVectorFst_NumArcs(self, *args)

    def SetStart(self, *args):
        """
        SetStart(self, int stateid)

        Set the start state.
        """
        return _openfst.StdVectorFst_SetStart(self, *args)

    def DeleteStates(self, *args):
        """
        DeleteStates(self, vector<(int)> arg0)
        DeleteStates(self)

        Delete all states from this FST.
        """
        return _openfst.StdVectorFst_DeleteStates(self, *args)

    def DeleteArcs(self, *args):
        """
        DeleteArcs(self, int stateid, size_t n)
        DeleteArcs(self, int stateid)

        Delete all outgoing arcs from a state.
        """
        return _openfst.StdVectorFst_DeleteArcs(self, *args)

    def SetFinal(self, *args):
        """
        SetFinal(self, int stateid, float weight)

        Mark the given state as final, with the specified weight.
        """
        return _openfst.StdVectorFst_SetFinal(self, *args)

    def ReserveStates(self, *args):
        """
        ReserveStates(self, int stateid)

        Reserve space for new states up to the given ID.
        """
        return _openfst.StdVectorFst_ReserveStates(self, *args)

    def ReserveArcs(self, *args):
        """
        ReserveArcs(self, int stateid, int n)

        Reserve space for n arcs leaving the given state ID.
        """
        return _openfst.StdVectorFst_ReserveArcs(self, *args)

    def InputSymbols(self):
        """
        InputSymbols(self) -> SymbolTable

        Returns the input symbol table.
        """
        return _openfst.StdVectorFst_InputSymbols(self)

    def OutputSymbols(self):
        """
        OutputSymbols(self) -> SymbolTable

        Returns the output symbol table.
        """
        return _openfst.StdVectorFst_OutputSymbols(self)

    def SetInputSymbols(self, *args):
        """
        SetInputSymbols(self, SymbolTable symtab)

        Sets the input symbol table.  Because of the semantics of SWIG, this
        incurs a copy, and thus you should call it just before writing the FST
        to a file, or any changes you may have made to the given symbol table
        will not be reflected in the output file.
        """
        return _openfst.StdVectorFst_SetInputSymbols(self, *args)

    def SetOutputSymbols(self, *args):
        """
        SetOutputSymbols(self, SymbolTable symtab)

        Sets the output symbol table.  Because of the semantics of SWIG, this
        incurs a copy, and thus you should call it just before writing the FST
        to a file, or any changes you may have made to the given symbol table
        will not be reflected in the output file.
        """
        return _openfst.StdVectorFst_SetOutputSymbols(self, *args)

    def Properties(self, *args):
        """
        Properties(self, uint64 mask, bool test) -> uint64

        Returns the properties for this FST.
        """
        return _openfst.StdVectorFst_Properties(self, *args)

    def Read(*args):
        """
        Read(string filename) -> StdVectorFst

        Read an FST from a binary file.
        """
        return _openfst.StdVectorFst_Read(*args)

    if _newclass:Read = staticmethod(Read)
    __swig_getmethods__["Read"] = lambda x: Read
    def Write(self, *args):
        """
        Write(self, string filename) -> bool

        Write this FST to a binary file.
        """
        return _openfst.StdVectorFst_Write(self, *args)

    def Copy(self, reset = False):
        """
        Copy(self, bool reset = False) -> StdVectorFst
        Copy(self) -> StdVectorFst

        Returns a copy of this FST.
        """
        return _openfst.StdVectorFst_Copy(self, reset)

    def IsFinal(self, *args):
        """
        IsFinal(self, int state) -> bool

        Convenience function to test if a state is final.
        Use this instead of the Final() method

        """
        return _openfst.StdVectorFst_IsFinal(self, *args)

    def FinalWeight(self, *args):
        """
        FinalWeight(self, int state) -> float

        Get the final weight for the given state.  Use this instead of
        the Final() method.
        """
        return _openfst.StdVectorFst_FinalWeight(self, *args)

    def SetNotFinal(self, *args):
        """
        SetNotFinal(self, int state)

        Set a state as not being final.  Use this instead of the
        SetFinal() method (SWIG won't allow you to pass inf to it).
        """
        return _openfst.StdVectorFst_SetNotFinal(self, *args)

    def AddArc(self, *args):
        """
        AddArc(self, int stateid, StdArc arc)
        AddArc(self, int _from, int ilabel, int olabel, float weight, int to)

        Convenience method which adds an arc without the need to
        explicitly create a StdArc object.
        """
        return _openfst.StdVectorFst_AddArc(self, *args)

    def GetArc(self, *args):
        """
        GetArc(self, int i, int j) -> StdArc

        Convenience method which returns the jth arc exiting state i.
        """
        return _openfst.StdVectorFst_GetArc(self, *args)

    def GetInput(self, *args):
        """
        GetInput(self, int i, int j) -> int

        Convenience method which returns the input label for the jth
        arc exiting state i.
        """
        return _openfst.StdVectorFst_GetInput(self, *args)

    def GetOutput(self, *args):
        """
        GetOutput(self, int i, int j) -> int

        Convenience method which returns the output label for the jth
        arc exiting state i.
        """
        return _openfst.StdVectorFst_GetOutput(self, *args)

    def GetWeight(self, *args):
        """
        GetWeight(self, int i, int j) -> float

        Convenience method which returns the weight for the jth
        arc exiting state i.
        """
        return _openfst.StdVectorFst_GetWeight(self, *args)

    def GetNext(self, *args):
        """
        GetNext(self, int i, int j) -> int

        Convenience method which returns the target state for the jth
        arc exiting state i.
        """
        return _openfst.StdVectorFst_GetNext(self, *args)

    def AddString(self, *args):
        """
        AddString(self, char s, float icost = 0.0, float fcost = 0.0, float ccost = 0.0)
        AddString(self, char s, float icost = 0.0, float fcost = 0.0)
        AddString(self, char s, float icost = 0.0)
        AddString(self, char s)

        Add nodes and arcs to recognize a character string.
        """
        return _openfst.StdVectorFst_AddString(self, *args)

    def AddWString(self, *args):
        """
        AddWString(self, wchar_t s, float icost = 0.0, float fcost = 0.0, float ccost = 0.0)
        AddWString(self, wchar_t s, float icost = 0.0, float fcost = 0.0)
        AddWString(self, wchar_t s, float icost = 0.0)
        AddWString(self, wchar_t s)

        Add nodes and arcs to recognize a wide character string.
        """
        return _openfst.StdVectorFst_AddWString(self, *args)

    def AddTranslation(self, *args):
        """
        AddTranslation(self, char _in, char out, float icost = 0.0, float fcost = 0.0, 
            float ccost = 0.0)
        AddTranslation(self, char _in, char out, float icost = 0.0, float fcost = 0.0)
        AddTranslation(self, char _in, char out, float icost = 0.0)
        AddTranslation(self, char _in, char out)

        Add nodes and arcs to transduce one string into another.
        """
        return _openfst.StdVectorFst_AddTranslation(self, *args)

    def AddWTranslation(self, *args):
        """
        AddWTranslation(self, wchar_t _in, wchar_t out, float icost = 0.0, float fcost = 0.0, 
            float ccost = 0.0)
        AddWTranslation(self, wchar_t _in, wchar_t out, float icost = 0.0, float fcost = 0.0)
        AddWTranslation(self, wchar_t _in, wchar_t out, float icost = 0.0)
        AddWTranslation(self, wchar_t _in, wchar_t out)

        Add nodes and arcs to transduce one wide character string into another.
        """
        return _openfst.StdVectorFst_AddWTranslation(self, *args)

    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(StdStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(StdArcIterator(self, stateid))

    def mutable_iterarcs(self, stateid):
        """Return a mutable iterator over outgoing arcs from stateid."""
        return Fst_mutable_arc_iter(StdMutableArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_StdVectorFst
    __del__ = lambda self : None;
StdVectorFst_swigregister = _openfst.StdVectorFst_swigregister
StdVectorFst_swigregister(StdVectorFst)

def StdVectorFst_Read(*args):
  """
    StdVectorFst_Read(string filename) -> StdVectorFst

    Read an FST from a binary file.
    """
  return _openfst.StdVectorFst_Read(*args)

class LogVectorFst(LogMutableFst):
    """Proxy of C++ VectorFst<(LogArc)> class"""
    __swig_setmethods__ = {}
    for _s in [LogMutableFst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogVectorFst, name, value)
    __swig_getmethods__ = {}
    for _s in [LogMutableFst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LogVectorFst, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LogVectorFst
        __init__(self, LogFst fst) -> LogVectorFst

        constructor
        """
        this = _openfst.new_LogVectorFst(*args)
        try: self.this.append(this)
        except: self.this = this
    def AddState(self):
        """
        AddState(self) -> int

        Add a new state to this FST.  Returns the ID of this new state.
        """
        return _openfst.LogVectorFst_AddState(self)

    def Start(self):
        """
        Start(self) -> int

        Get the start state ID of this FST.
        """
        return _openfst.LogVectorFst_Start(self)

    def Final(self, *args):
        """
        Final(self, int stateid) -> Weight

        Check if the given state is a final state.  Returns its weight if
        it is final, otherwise returns Weight.Zero() = inf.  Use IsFinal()
        instead if all you are interested in doing is checking for finality.
        """
        return _openfst.LogVectorFst_Final(self, *args)

    def NumStates(self):
        """
        NumStates(self) -> int

        Returns the number of states in this FST.
        """
        return _openfst.LogVectorFst_NumStates(self)

    def NumArcs(self, *args):
        """
        NumArcs(self, int stateid) -> int

        Returns the number of arcs leaving the given state.
        """
        return _openfst.LogVectorFst_NumArcs(self, *args)

    def SetStart(self, *args):
        """
        SetStart(self, int stateid)

        Set the start state.
        """
        return _openfst.LogVectorFst_SetStart(self, *args)

    def DeleteStates(self, *args):
        """
        DeleteStates(self, vector<(int)> arg0)
        DeleteStates(self)

        Delete all states from this FST.
        """
        return _openfst.LogVectorFst_DeleteStates(self, *args)

    def DeleteArcs(self, *args):
        """
        DeleteArcs(self, int stateid, size_t n)
        DeleteArcs(self, int stateid)

        Delete all outgoing arcs from a state.
        """
        return _openfst.LogVectorFst_DeleteArcs(self, *args)

    def SetFinal(self, *args):
        """
        SetFinal(self, int stateid, float weight)

        Mark the given state as final, with the specified weight.
        """
        return _openfst.LogVectorFst_SetFinal(self, *args)

    def ReserveStates(self, *args):
        """
        ReserveStates(self, int stateid)

        Reserve space for new states up to the given ID.
        """
        return _openfst.LogVectorFst_ReserveStates(self, *args)

    def ReserveArcs(self, *args):
        """
        ReserveArcs(self, int stateid, int n)

        Reserve space for n arcs leaving the given state ID.
        """
        return _openfst.LogVectorFst_ReserveArcs(self, *args)

    def InputSymbols(self):
        """
        InputSymbols(self) -> SymbolTable

        Returns the input symbol table.
        """
        return _openfst.LogVectorFst_InputSymbols(self)

    def OutputSymbols(self):
        """
        OutputSymbols(self) -> SymbolTable

        Returns the output symbol table.
        """
        return _openfst.LogVectorFst_OutputSymbols(self)

    def SetInputSymbols(self, *args):
        """
        SetInputSymbols(self, SymbolTable symtab)

        Sets the input symbol table.  Because of the semantics of SWIG, this
        incurs a copy, and thus you should call it just before writing the FST
        to a file, or any changes you may have made to the given symbol table
        will not be reflected in the output file.
        """
        return _openfst.LogVectorFst_SetInputSymbols(self, *args)

    def SetOutputSymbols(self, *args):
        """
        SetOutputSymbols(self, SymbolTable symtab)

        Sets the output symbol table.  Because of the semantics of SWIG, this
        incurs a copy, and thus you should call it just before writing the FST
        to a file, or any changes you may have made to the given symbol table
        will not be reflected in the output file.
        """
        return _openfst.LogVectorFst_SetOutputSymbols(self, *args)

    def Properties(self, *args):
        """
        Properties(self, uint64 mask, bool test) -> uint64

        Returns the properties for this FST.
        """
        return _openfst.LogVectorFst_Properties(self, *args)

    def Read(*args):
        """
        Read(string filename) -> StdVectorFst

        Read an FST from a binary file.
        """
        return _openfst.LogVectorFst_Read(*args)

    if _newclass:Read = staticmethod(Read)
    __swig_getmethods__["Read"] = lambda x: Read
    def Write(self, *args):
        """
        Write(self, string filename) -> bool

        Write this FST to a binary file.
        """
        return _openfst.LogVectorFst_Write(self, *args)

    def Copy(self, reset = False):
        """
        Copy(self, bool reset = False) -> LogVectorFst
        Copy(self) -> LogVectorFst

        Returns a copy of this FST.
        """
        return _openfst.LogVectorFst_Copy(self, reset)

    def IsFinal(self, *args):
        """
        IsFinal(self, int state) -> bool

        Convenience function to test if a state is final.
        Use this instead of the Final() method

        """
        return _openfst.LogVectorFst_IsFinal(self, *args)

    def FinalWeight(self, *args):
        """
        FinalWeight(self, int state) -> float

        Get the final weight for the given state.  Use this instead of
        the Final() method.
        """
        return _openfst.LogVectorFst_FinalWeight(self, *args)

    def SetNotFinal(self, *args):
        """
        SetNotFinal(self, int state)

        Set a state as not being final.  Use this instead of the
        SetFinal() method (SWIG won't allow you to pass inf to it).
        """
        return _openfst.LogVectorFst_SetNotFinal(self, *args)

    def AddArc(self, *args):
        """
        AddArc(self, int stateid, LogArc arc)
        AddArc(self, int _from, int ilabel, int olabel, float weight, int to)

        Convenience method which adds an arc without the need to
        explicitly create a StdArc object.
        """
        return _openfst.LogVectorFst_AddArc(self, *args)

    def GetArc(self, *args):
        """
        GetArc(self, int i, int j) -> LogArc

        Convenience method which returns the jth arc exiting state i.
        """
        return _openfst.LogVectorFst_GetArc(self, *args)

    def GetInput(self, *args):
        """
        GetInput(self, int i, int j) -> int

        Convenience method which returns the input label for the jth
        arc exiting state i.
        """
        return _openfst.LogVectorFst_GetInput(self, *args)

    def GetOutput(self, *args):
        """
        GetOutput(self, int i, int j) -> int

        Convenience method which returns the output label for the jth
        arc exiting state i.
        """
        return _openfst.LogVectorFst_GetOutput(self, *args)

    def GetWeight(self, *args):
        """
        GetWeight(self, int i, int j) -> float

        Convenience method which returns the weight for the jth
        arc exiting state i.
        """
        return _openfst.LogVectorFst_GetWeight(self, *args)

    def GetNext(self, *args):
        """
        GetNext(self, int i, int j) -> int

        Convenience method which returns the target state for the jth
        arc exiting state i.
        """
        return _openfst.LogVectorFst_GetNext(self, *args)

    def AddString(self, *args):
        """
        AddString(self, char s, float icost = 0.0, float fcost = 0.0, float ccost = 0.0)
        AddString(self, char s, float icost = 0.0, float fcost = 0.0)
        AddString(self, char s, float icost = 0.0)
        AddString(self, char s)

        Add nodes and arcs to recognize a character string.
        """
        return _openfst.LogVectorFst_AddString(self, *args)

    def AddWString(self, *args):
        """
        AddWString(self, wchar_t s, float icost = 0.0, float fcost = 0.0, float ccost = 0.0)
        AddWString(self, wchar_t s, float icost = 0.0, float fcost = 0.0)
        AddWString(self, wchar_t s, float icost = 0.0)
        AddWString(self, wchar_t s)

        Add nodes and arcs to recognize a wide character string.
        """
        return _openfst.LogVectorFst_AddWString(self, *args)

    def AddTranslation(self, *args):
        """
        AddTranslation(self, char _in, char out, float icost = 0.0, float fcost = 0.0, 
            float ccost = 0.0)
        AddTranslation(self, char _in, char out, float icost = 0.0, float fcost = 0.0)
        AddTranslation(self, char _in, char out, float icost = 0.0)
        AddTranslation(self, char _in, char out)

        Add nodes and arcs to transduce one string into another.
        """
        return _openfst.LogVectorFst_AddTranslation(self, *args)

    def AddWTranslation(self, *args):
        """
        AddWTranslation(self, wchar_t _in, wchar_t out, float icost = 0.0, float fcost = 0.0, 
            float ccost = 0.0)
        AddWTranslation(self, wchar_t _in, wchar_t out, float icost = 0.0, float fcost = 0.0)
        AddWTranslation(self, wchar_t _in, wchar_t out, float icost = 0.0)
        AddWTranslation(self, wchar_t _in, wchar_t out)

        Add nodes and arcs to transduce one wide character string into another.
        """
        return _openfst.LogVectorFst_AddWTranslation(self, *args)

    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(LogStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(LogArcIterator(self, stateid))

    def mutable_iterarcs(self, stateid):
        """Return a mutable iterator over outgoing arcs from stateid."""
        return Fst_mutable_arc_iter(LogMutableArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_LogVectorFst
    __del__ = lambda self : None;
LogVectorFst_swigregister = _openfst.LogVectorFst_swigregister
LogVectorFst_swigregister(LogVectorFst)

def LogVectorFst_Read(*args):
  """
    LogVectorFst_Read(string filename) -> StdVectorFst

    Read an FST from a binary file.
    """
  return _openfst.LogVectorFst_Read(*args)

class StdStateIterator(_object):
    """Proxy of C++ StateIterator<(StdFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdStateIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdStateIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StdFst fst) -> StdStateIterator

        constructor
        """
        this = _openfst.new_StdStateIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Next(self):
        """
        Next(self)

        Advance the iterator.
        """
        return _openfst.StdStateIterator_Next(self)

    def Reset(self):
        """
        Reset(self)

        Reset the iterator.
        """
        return _openfst.StdStateIterator_Reset(self)

    def Done(self):
        """
        Done(self) -> bool

        Returns true if the iterator is done.
        """
        return _openfst.StdStateIterator_Done(self)

    def Value(self):
        """
        Value(self) -> int

        Get the state ID the iterator is currently pointing to.
        """
        return _openfst.StdStateIterator_Value(self)

    __swig_destroy__ = _openfst.delete_StdStateIterator
    __del__ = lambda self : None;
StdStateIterator_swigregister = _openfst.StdStateIterator_swigregister
StdStateIterator_swigregister(StdStateIterator)

class LogStateIterator(_object):
    """Proxy of C++ StateIterator<(LogFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogStateIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogStateIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, LogFst fst) -> LogStateIterator

        constructor
        """
        this = _openfst.new_LogStateIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Next(self):
        """
        Next(self)

        Advance the iterator.
        """
        return _openfst.LogStateIterator_Next(self)

    def Reset(self):
        """
        Reset(self)

        Reset the iterator.
        """
        return _openfst.LogStateIterator_Reset(self)

    def Done(self):
        """
        Done(self) -> bool

        Returns true if the iterator is done.
        """
        return _openfst.LogStateIterator_Done(self)

    def Value(self):
        """
        Value(self) -> int

        Get the state ID the iterator is currently pointing to.
        """
        return _openfst.LogStateIterator_Value(self)

    __swig_destroy__ = _openfst.delete_LogStateIterator
    __del__ = lambda self : None;
LogStateIterator_swigregister = _openfst.LogStateIterator_swigregister
LogStateIterator_swigregister(LogStateIterator)

class StdArcIterator(_object):
    """Proxy of C++ ArcIterator<(StdFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdArcIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdArcIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StdFst fst, int stateid) -> StdArcIterator

        constructor
        """
        this = _openfst.new_StdArcIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Next(self):
        """
        Next(self)

        Advance the iterator.
        """
        return _openfst.StdArcIterator_Next(self)

    def Reset(self):
        """
        Reset(self)

        Reset the iterator.
        """
        return _openfst.StdArcIterator_Reset(self)

    def Seek(self, *args):
        """
        Seek(self, unsigned long pos)

        Seek to position.
        """
        return _openfst.StdArcIterator_Seek(self, *args)

    def Position(self):
        """
        Position(self) -> unsigned long

        Get current position.
        """
        return _openfst.StdArcIterator_Position(self)

    def Done(self):
        """
        Done(self) -> bool

        Returns true if the iterator is done.
        """
        return _openfst.StdArcIterator_Done(self)

    def Value(self):
        """
        Value(self) -> ArcIterator<(Fst<(ArcTpl<(TropicalWeight)>)>)>::Arc

        Get the arc the iterator is currently pointing to.
        """
        return _openfst.StdArcIterator_Value(self)

    __swig_destroy__ = _openfst.delete_StdArcIterator
    __del__ = lambda self : None;
StdArcIterator_swigregister = _openfst.StdArcIterator_swigregister
StdArcIterator_swigregister(StdArcIterator)

class LogArcIterator(_object):
    """Proxy of C++ ArcIterator<(LogFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogArcIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogArcIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, LogFst fst, int stateid) -> LogArcIterator

        constructor
        """
        this = _openfst.new_LogArcIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Next(self):
        """
        Next(self)

        Advance the iterator.
        """
        return _openfst.LogArcIterator_Next(self)

    def Reset(self):
        """
        Reset(self)

        Reset the iterator.
        """
        return _openfst.LogArcIterator_Reset(self)

    def Seek(self, *args):
        """
        Seek(self, unsigned long pos)

        Seek to position.
        """
        return _openfst.LogArcIterator_Seek(self, *args)

    def Position(self):
        """
        Position(self) -> unsigned long

        Get current position.
        """
        return _openfst.LogArcIterator_Position(self)

    def Done(self):
        """
        Done(self) -> bool

        Returns true if the iterator is done.
        """
        return _openfst.LogArcIterator_Done(self)

    def Value(self):
        """
        Value(self) -> ArcIterator<(Fst<(ArcTpl<(LogWeight)>)>)>::Arc

        Get the arc the iterator is currently pointing to.
        """
        return _openfst.LogArcIterator_Value(self)

    __swig_destroy__ = _openfst.delete_LogArcIterator
    __del__ = lambda self : None;
LogArcIterator_swigregister = _openfst.LogArcIterator_swigregister
LogArcIterator_swigregister(LogArcIterator)

class StdMutableArcIterator(_object):
    """Proxy of C++ MutableArcIterator<(StdMutableFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdMutableArcIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdMutableArcIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StdMutableFst fst, int stateid) -> StdMutableArcIterator

        constructor
        """
        this = _openfst.new_StdMutableArcIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Next(self):
        """
        Next(self)

        Advance the iterator.
        """
        return _openfst.StdMutableArcIterator_Next(self)

    def Reset(self):
        """
        Reset(self)

        Reset the iterator.
        """
        return _openfst.StdMutableArcIterator_Reset(self)

    def Seek(self, *args):
        """
        Seek(self, unsigned long pos)

        Seek to position.
        """
        return _openfst.StdMutableArcIterator_Seek(self, *args)

    def Position(self):
        """
        Position(self) -> unsigned long

        Get current position.
        """
        return _openfst.StdMutableArcIterator_Position(self)

    def Done(self):
        """
        Done(self) -> bool

        Returns true if the iterator is done.
        """
        return _openfst.StdMutableArcIterator_Done(self)

    def Value(self):
        """
        Value(self) -> MutableArcIterator<(MutableFst<(ArcTpl<(TropicalWeight)>)>)>::Arc

        Get the arc the iterator is currently pointing to.
        """
        return _openfst.StdMutableArcIterator_Value(self)

    def SetValue(self, *args):
        """
        SetValue(self, MutableArcIterator<(MutableFst<(ArcTpl<(TropicalWeight)>)>)>::Arc arc)

        Modify the arc the iterator is currently pointing to.
        """
        return _openfst.StdMutableArcIterator_SetValue(self, *args)

    __swig_destroy__ = _openfst.delete_StdMutableArcIterator
    __del__ = lambda self : None;
StdMutableArcIterator_swigregister = _openfst.StdMutableArcIterator_swigregister
StdMutableArcIterator_swigregister(StdMutableArcIterator)

class LogMutableArcIterator(_object):
    """Proxy of C++ MutableArcIterator<(LogMutableFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogMutableArcIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogMutableArcIterator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, LogMutableFst fst, int stateid) -> LogMutableArcIterator

        constructor
        """
        this = _openfst.new_LogMutableArcIterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def Next(self):
        """
        Next(self)

        Advance the iterator.
        """
        return _openfst.LogMutableArcIterator_Next(self)

    def Reset(self):
        """
        Reset(self)

        Reset the iterator.
        """
        return _openfst.LogMutableArcIterator_Reset(self)

    def Seek(self, *args):
        """
        Seek(self, unsigned long pos)

        Seek to position.
        """
        return _openfst.LogMutableArcIterator_Seek(self, *args)

    def Position(self):
        """
        Position(self) -> unsigned long

        Get current position.
        """
        return _openfst.LogMutableArcIterator_Position(self)

    def Done(self):
        """
        Done(self) -> bool

        Returns true if the iterator is done.
        """
        return _openfst.LogMutableArcIterator_Done(self)

    def Value(self):
        """
        Value(self) -> MutableArcIterator<(MutableFst<(ArcTpl<(LogWeight)>)>)>::Arc

        Get the arc the iterator is currently pointing to.
        """
        return _openfst.LogMutableArcIterator_Value(self)

    def SetValue(self, *args):
        """
        SetValue(self, MutableArcIterator<(MutableFst<(ArcTpl<(LogWeight)>)>)>::Arc arc)

        Modify the arc the iterator is currently pointing to.
        """
        return _openfst.LogMutableArcIterator_SetValue(self, *args)

    __swig_destroy__ = _openfst.delete_LogMutableArcIterator
    __del__ = lambda self : None;
LogMutableArcIterator_swigregister = _openfst.LogMutableArcIterator_swigregister
LogMutableArcIterator_swigregister(LogMutableArcIterator)

class StdComposeFst(StdFst):
    """Proxy of C++ ComposeFst<(StdArc)> class"""
    __swig_setmethods__ = {}
    for _s in [StdFst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdComposeFst, name, value)
    __swig_getmethods__ = {}
    for _s in [StdFst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StdComposeFst, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, StdFst fst1, StdFst fst2) -> StdComposeFst
        __init__(self, StdFst fst1, StdFst fst2, StdSigmaComposeOptions opts) -> StdComposeFst
        __init__(self, StdFst fst1, StdFst fst2, StdRhoComposeOptions opts) -> StdComposeFst
        __init__(self, StdFst fst1, StdFst fst2, StdPhiComposeOptions opts) -> StdComposeFst
        __init__(self, StdFst fst1, StdFst fst2, ComposeFstOptions<(ArcTpl<(TropicalWeight)>,RhoMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>,PushWeightsComposeFilter<(Fst<(ArcTpl<(TropicalWeight)>)>,LookAheadMatcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>,RhoMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>)>)> arg2) -> StdComposeFst

        Construct a lazy composition of FSTs A and B.
        """
        this = _openfst.new_StdComposeFst(*args)
        try: self.this.append(this)
        except: self.this = this
    def Start(self):
        """
        Start(self) -> int

        Get the start state ID of this FST.
        """
        return _openfst.StdComposeFst_Start(self)

    def Final(self, *args):
        """
        Final(self, int stateid) -> ArcTpl<(TropicalWeight)>::Weight

        Check if the given state is a final state.  Returns its weight if
        it is final, otherwise returns Weight.Zero() = inf.  Use IsFinal()
        instead if all you are interested in doing is checking for finality.
        """
        return _openfst.StdComposeFst_Final(self, *args)

    def NumArcs(self, *args):
        """
        NumArcs(self, int stateid) -> int

        Returns the number of arcs leaving the given state.
        """
        return _openfst.StdComposeFst_NumArcs(self, *args)

    def InputSymbols(self):
        """
        InputSymbols(self) -> SymbolTable

        Returns the input symbol table.
        """
        return _openfst.StdComposeFst_InputSymbols(self)

    def OutputSymbols(self):
        """
        OutputSymbols(self) -> SymbolTable

        Returns the output symbol table.
        """
        return _openfst.StdComposeFst_OutputSymbols(self)

    def IsFinal(self, *args):
        """
        IsFinal(self, int state) -> bool

        Convenience function to test if a state is final.
        Use this instead of the Final() method

        """
        return _openfst.StdComposeFst_IsFinal(self, *args)

    def FinalWeight(self, *args):
        """
        FinalWeight(self, int state) -> float

        Get the final weight for the given state.  Use this instead of
        the Final() method.
        """
        return _openfst.StdComposeFst_FinalWeight(self, *args)

    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(StdStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(StdArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_StdComposeFst
    __del__ = lambda self : None;
StdComposeFst_swigregister = _openfst.StdComposeFst_swigregister
StdComposeFst_swigregister(StdComposeFst)

class LogComposeFst(LogFst):
    """Proxy of C++ ComposeFst<(LogArc)> class"""
    __swig_setmethods__ = {}
    for _s in [LogFst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogComposeFst, name, value)
    __swig_getmethods__ = {}
    for _s in [LogFst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LogComposeFst, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, LogFst fst1, LogFst fst2) -> LogComposeFst
        __init__(self, LogFst fst1, LogFst fst2, ComposeFstOptions<(ArcTpl<(LogWeight)>,SigmaMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>)> opts) -> LogComposeFst
        __init__(self, LogFst fst1, LogFst fst2, ComposeFstOptions<(ArcTpl<(LogWeight)>,RhoMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>)> opts) -> LogComposeFst
        __init__(self, LogFst fst1, LogFst fst2, ComposeFstOptions<(ArcTpl<(LogWeight)>,PhiMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>)> opts) -> LogComposeFst
        __init__(self, LogFst fst1, LogFst fst2, ComposeFstOptions<(ArcTpl<(LogWeight)>,RhoMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>,PushWeightsComposeFilter<(Fst<(ArcTpl<(LogWeight)>)>,LookAheadMatcher<(Fst<(ArcTpl<(LogWeight)>)>)>,RhoMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>)>)> arg2) -> LogComposeFst

        Construct a lazy composition of FSTs A and B.
        """
        this = _openfst.new_LogComposeFst(*args)
        try: self.this.append(this)
        except: self.this = this
    def Start(self):
        """
        Start(self) -> int

        Get the start state ID of this FST.
        """
        return _openfst.LogComposeFst_Start(self)

    def Final(self, *args):
        """
        Final(self, int stateid) -> Weight

        Check if the given state is a final state.  Returns its weight if
        it is final, otherwise returns Weight.Zero() = inf.  Use IsFinal()
        instead if all you are interested in doing is checking for finality.
        """
        return _openfst.LogComposeFst_Final(self, *args)

    def NumArcs(self, *args):
        """
        NumArcs(self, int stateid) -> int

        Returns the number of arcs leaving the given state.
        """
        return _openfst.LogComposeFst_NumArcs(self, *args)

    def InputSymbols(self):
        """
        InputSymbols(self) -> SymbolTable

        Returns the input symbol table.
        """
        return _openfst.LogComposeFst_InputSymbols(self)

    def OutputSymbols(self):
        """
        OutputSymbols(self) -> SymbolTable

        Returns the output symbol table.
        """
        return _openfst.LogComposeFst_OutputSymbols(self)

    def IsFinal(self, *args):
        """
        IsFinal(self, int state) -> bool

        Convenience function to test if a state is final.
        Use this instead of the Final() method

        """
        return _openfst.LogComposeFst_IsFinal(self, *args)

    def FinalWeight(self, *args):
        """
        FinalWeight(self, int state) -> float

        Get the final weight for the given state.  Use this instead of
        the Final() method.
        """
        return _openfst.LogComposeFst_FinalWeight(self, *args)

    def __iter__(self):
        """Return an iterator over state IDs."""
        return Fst_state_iter(LogStateIterator(self))

    def iterarcs(self, stateid):
        """Return an iterator over outgoing arcs from stateid."""
        return Fst_arc_iter(LogArcIterator(self, stateid))

    __swig_destroy__ = _openfst.delete_LogComposeFst
    __del__ = lambda self : None;
LogComposeFst_swigregister = _openfst.LogComposeFst_swigregister
LogComposeFst_swigregister(LogComposeFst)

class StdMatcher(_object):
    """Proxy of C++ Matcher<(StdFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>::FST fst, 
            MatchType match_type) -> StdMatcher
        """
        this = _openfst.new_StdMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdMatcher
    __del__ = lambda self : None;
StdMatcher_swigregister = _openfst.StdMatcher_swigregister
StdMatcher_swigregister(StdMatcher)

class LogMatcher(_object):
    """Proxy of C++ Matcher<(LogFst)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>::FST fst, MatchType match_type) -> LogMatcher"""
        this = _openfst.new_LogMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogMatcher
    __del__ = lambda self : None;
LogMatcher_swigregister = _openfst.LogMatcher_swigregister
LogMatcher_swigregister(LogMatcher)

class StdRhoMatcher(_object):
    """Proxy of C++ RhoMatcher<(StdMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdRhoMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdRhoMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, RhoMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int rho_label = kNoLabel, 
            MatcherRewriteMode rewrite_mode = MATCHER_REWRITE_AUTO) -> StdRhoMatcher
        __init__(self, RhoMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int rho_label = kNoLabel) -> StdRhoMatcher
        __init__(self, RhoMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type) -> StdRhoMatcher
        """
        this = _openfst.new_StdRhoMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdRhoMatcher
    __del__ = lambda self : None;
StdRhoMatcher_swigregister = _openfst.StdRhoMatcher_swigregister
StdRhoMatcher_swigregister(StdRhoMatcher)

class LogRhoMatcher(_object):
    """Proxy of C++ RhoMatcher<(LogMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogRhoMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogRhoMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, RhoMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int rho_label = kNoLabel, 
            MatcherRewriteMode rewrite_mode = MATCHER_REWRITE_AUTO) -> LogRhoMatcher
        __init__(self, RhoMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int rho_label = kNoLabel) -> LogRhoMatcher
        __init__(self, RhoMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type) -> LogRhoMatcher
        """
        this = _openfst.new_LogRhoMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogRhoMatcher
    __del__ = lambda self : None;
LogRhoMatcher_swigregister = _openfst.LogRhoMatcher_swigregister
LogRhoMatcher_swigregister(LogRhoMatcher)

class StdRhoComposeOptions(_object):
    """Proxy of C++ ComposeFstOptions<(StdArc,StdRhoMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdRhoComposeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdRhoComposeOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["gc"] = _openfst.StdRhoComposeOptions_gc_set
    __swig_getmethods__["gc"] = _openfst.StdRhoComposeOptions_gc_get
    if _newclass:gc = _swig_property(_openfst.StdRhoComposeOptions_gc_get, _openfst.StdRhoComposeOptions_gc_set)
    __swig_setmethods__["gc_limit"] = _openfst.StdRhoComposeOptions_gc_limit_set
    __swig_getmethods__["gc_limit"] = _openfst.StdRhoComposeOptions_gc_limit_get
    if _newclass:gc_limit = _swig_property(_openfst.StdRhoComposeOptions_gc_limit_get, _openfst.StdRhoComposeOptions_gc_limit_set)
    __swig_setmethods__["matcher1"] = _openfst.StdRhoComposeOptions_matcher1_set
    __swig_getmethods__["matcher1"] = _openfst.StdRhoComposeOptions_matcher1_get
    if _newclass:matcher1 = _swig_property(_openfst.StdRhoComposeOptions_matcher1_get, _openfst.StdRhoComposeOptions_matcher1_set)
    __swig_setmethods__["matcher2"] = _openfst.StdRhoComposeOptions_matcher2_set
    __swig_getmethods__["matcher2"] = _openfst.StdRhoComposeOptions_matcher2_get
    if _newclass:matcher2 = _swig_property(_openfst.StdRhoComposeOptions_matcher2_get, _openfst.StdRhoComposeOptions_matcher2_set)
    __swig_setmethods__["filter"] = _openfst.StdRhoComposeOptions_filter_set
    __swig_getmethods__["filter"] = _openfst.StdRhoComposeOptions_filter_get
    if _newclass:filter = _swig_property(_openfst.StdRhoComposeOptions_filter_get, _openfst.StdRhoComposeOptions_filter_set)
    def __init__(self): 
        """__init__(self) -> StdRhoComposeOptions"""
        this = _openfst.new_StdRhoComposeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdRhoComposeOptions
    __del__ = lambda self : None;
StdRhoComposeOptions_swigregister = _openfst.StdRhoComposeOptions_swigregister
StdRhoComposeOptions_swigregister(StdRhoComposeOptions)

class LogRhoComposeOptions(_object):
    """Proxy of C++ ComposeFstOptions<(StdArc,LogRhoMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogRhoComposeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogRhoComposeOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["gc"] = _openfst.LogRhoComposeOptions_gc_set
    __swig_getmethods__["gc"] = _openfst.LogRhoComposeOptions_gc_get
    if _newclass:gc = _swig_property(_openfst.LogRhoComposeOptions_gc_get, _openfst.LogRhoComposeOptions_gc_set)
    __swig_setmethods__["gc_limit"] = _openfst.LogRhoComposeOptions_gc_limit_set
    __swig_getmethods__["gc_limit"] = _openfst.LogRhoComposeOptions_gc_limit_get
    if _newclass:gc_limit = _swig_property(_openfst.LogRhoComposeOptions_gc_limit_get, _openfst.LogRhoComposeOptions_gc_limit_set)
    __swig_setmethods__["matcher1"] = _openfst.LogRhoComposeOptions_matcher1_set
    __swig_getmethods__["matcher1"] = _openfst.LogRhoComposeOptions_matcher1_get
    if _newclass:matcher1 = _swig_property(_openfst.LogRhoComposeOptions_matcher1_get, _openfst.LogRhoComposeOptions_matcher1_set)
    __swig_setmethods__["matcher2"] = _openfst.LogRhoComposeOptions_matcher2_set
    __swig_getmethods__["matcher2"] = _openfst.LogRhoComposeOptions_matcher2_get
    if _newclass:matcher2 = _swig_property(_openfst.LogRhoComposeOptions_matcher2_get, _openfst.LogRhoComposeOptions_matcher2_set)
    __swig_setmethods__["filter"] = _openfst.LogRhoComposeOptions_filter_set
    __swig_getmethods__["filter"] = _openfst.LogRhoComposeOptions_filter_get
    if _newclass:filter = _swig_property(_openfst.LogRhoComposeOptions_filter_get, _openfst.LogRhoComposeOptions_filter_set)
    def __init__(self): 
        """__init__(self) -> LogRhoComposeOptions"""
        this = _openfst.new_LogRhoComposeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogRhoComposeOptions
    __del__ = lambda self : None;
LogRhoComposeOptions_swigregister = _openfst.LogRhoComposeOptions_swigregister
LogRhoComposeOptions_swigregister(LogRhoComposeOptions)

class StdSigmaMatcher(_object):
    """Proxy of C++ SigmaMatcher<(StdMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdSigmaMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdSigmaMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SigmaMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int sigma_label = kNoLabel, 
            MatcherRewriteMode rewrite_mode = MATCHER_REWRITE_AUTO) -> StdSigmaMatcher
        __init__(self, SigmaMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int sigma_label = kNoLabel) -> StdSigmaMatcher
        __init__(self, SigmaMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type) -> StdSigmaMatcher
        """
        this = _openfst.new_StdSigmaMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdSigmaMatcher
    __del__ = lambda self : None;
StdSigmaMatcher_swigregister = _openfst.StdSigmaMatcher_swigregister
StdSigmaMatcher_swigregister(StdSigmaMatcher)

class LogSigmaMatcher(_object):
    """Proxy of C++ SigmaMatcher<(LogMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogSigmaMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogSigmaMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, SigmaMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int sigma_label = kNoLabel, 
            MatcherRewriteMode rewrite_mode = MATCHER_REWRITE_AUTO) -> LogSigmaMatcher
        __init__(self, SigmaMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int sigma_label = kNoLabel) -> LogSigmaMatcher
        __init__(self, SigmaMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type) -> LogSigmaMatcher
        """
        this = _openfst.new_LogSigmaMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogSigmaMatcher
    __del__ = lambda self : None;
LogSigmaMatcher_swigregister = _openfst.LogSigmaMatcher_swigregister
LogSigmaMatcher_swigregister(LogSigmaMatcher)

class StdSigmaComposeOptions(_object):
    """Proxy of C++ ComposeFstOptions<(StdArc,StdSigmaMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdSigmaComposeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdSigmaComposeOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["gc"] = _openfst.StdSigmaComposeOptions_gc_set
    __swig_getmethods__["gc"] = _openfst.StdSigmaComposeOptions_gc_get
    if _newclass:gc = _swig_property(_openfst.StdSigmaComposeOptions_gc_get, _openfst.StdSigmaComposeOptions_gc_set)
    __swig_setmethods__["gc_limit"] = _openfst.StdSigmaComposeOptions_gc_limit_set
    __swig_getmethods__["gc_limit"] = _openfst.StdSigmaComposeOptions_gc_limit_get
    if _newclass:gc_limit = _swig_property(_openfst.StdSigmaComposeOptions_gc_limit_get, _openfst.StdSigmaComposeOptions_gc_limit_set)
    __swig_setmethods__["matcher1"] = _openfst.StdSigmaComposeOptions_matcher1_set
    __swig_getmethods__["matcher1"] = _openfst.StdSigmaComposeOptions_matcher1_get
    if _newclass:matcher1 = _swig_property(_openfst.StdSigmaComposeOptions_matcher1_get, _openfst.StdSigmaComposeOptions_matcher1_set)
    __swig_setmethods__["matcher2"] = _openfst.StdSigmaComposeOptions_matcher2_set
    __swig_getmethods__["matcher2"] = _openfst.StdSigmaComposeOptions_matcher2_get
    if _newclass:matcher2 = _swig_property(_openfst.StdSigmaComposeOptions_matcher2_get, _openfst.StdSigmaComposeOptions_matcher2_set)
    __swig_setmethods__["filter"] = _openfst.StdSigmaComposeOptions_filter_set
    __swig_getmethods__["filter"] = _openfst.StdSigmaComposeOptions_filter_get
    if _newclass:filter = _swig_property(_openfst.StdSigmaComposeOptions_filter_get, _openfst.StdSigmaComposeOptions_filter_set)
    def __init__(self): 
        """__init__(self) -> StdSigmaComposeOptions"""
        this = _openfst.new_StdSigmaComposeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdSigmaComposeOptions
    __del__ = lambda self : None;
StdSigmaComposeOptions_swigregister = _openfst.StdSigmaComposeOptions_swigregister
StdSigmaComposeOptions_swigregister(StdSigmaComposeOptions)

class LogSigmaComposeOptions(_object):
    """Proxy of C++ ComposeFstOptions<(StdArc,LogSigmaMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogSigmaComposeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogSigmaComposeOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["gc"] = _openfst.LogSigmaComposeOptions_gc_set
    __swig_getmethods__["gc"] = _openfst.LogSigmaComposeOptions_gc_get
    if _newclass:gc = _swig_property(_openfst.LogSigmaComposeOptions_gc_get, _openfst.LogSigmaComposeOptions_gc_set)
    __swig_setmethods__["gc_limit"] = _openfst.LogSigmaComposeOptions_gc_limit_set
    __swig_getmethods__["gc_limit"] = _openfst.LogSigmaComposeOptions_gc_limit_get
    if _newclass:gc_limit = _swig_property(_openfst.LogSigmaComposeOptions_gc_limit_get, _openfst.LogSigmaComposeOptions_gc_limit_set)
    __swig_setmethods__["matcher1"] = _openfst.LogSigmaComposeOptions_matcher1_set
    __swig_getmethods__["matcher1"] = _openfst.LogSigmaComposeOptions_matcher1_get
    if _newclass:matcher1 = _swig_property(_openfst.LogSigmaComposeOptions_matcher1_get, _openfst.LogSigmaComposeOptions_matcher1_set)
    __swig_setmethods__["matcher2"] = _openfst.LogSigmaComposeOptions_matcher2_set
    __swig_getmethods__["matcher2"] = _openfst.LogSigmaComposeOptions_matcher2_get
    if _newclass:matcher2 = _swig_property(_openfst.LogSigmaComposeOptions_matcher2_get, _openfst.LogSigmaComposeOptions_matcher2_set)
    __swig_setmethods__["filter"] = _openfst.LogSigmaComposeOptions_filter_set
    __swig_getmethods__["filter"] = _openfst.LogSigmaComposeOptions_filter_get
    if _newclass:filter = _swig_property(_openfst.LogSigmaComposeOptions_filter_get, _openfst.LogSigmaComposeOptions_filter_set)
    def __init__(self): 
        """__init__(self) -> LogSigmaComposeOptions"""
        this = _openfst.new_LogSigmaComposeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogSigmaComposeOptions
    __del__ = lambda self : None;
LogSigmaComposeOptions_swigregister = _openfst.LogSigmaComposeOptions_swigregister
LogSigmaComposeOptions_swigregister(LogSigmaComposeOptions)

class StdPhiMatcher(_object):
    """Proxy of C++ PhiMatcher<(StdMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdPhiMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdPhiMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int phi_label = kNoLabel, 
            bool phi_loop = True, MatcherRewriteMode rewrite_mode = MATCHER_REWRITE_AUTO) -> StdPhiMatcher
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int phi_label = kNoLabel, 
            bool phi_loop = True) -> StdPhiMatcher
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type, int phi_label = kNoLabel) -> StdPhiMatcher
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(TropicalWeight)>)>)>)>::FST fst, 
            MatchType match_type) -> StdPhiMatcher
        """
        this = _openfst.new_StdPhiMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdPhiMatcher
    __del__ = lambda self : None;
StdPhiMatcher_swigregister = _openfst.StdPhiMatcher_swigregister
StdPhiMatcher_swigregister(StdPhiMatcher)

class LogPhiMatcher(_object):
    """Proxy of C++ PhiMatcher<(LogMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogPhiMatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogPhiMatcher, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int phi_label = kNoLabel, 
            bool phi_loop = True, MatcherRewriteMode rewrite_mode = MATCHER_REWRITE_AUTO) -> LogPhiMatcher
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int phi_label = kNoLabel, 
            bool phi_loop = True) -> LogPhiMatcher
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type, int phi_label = kNoLabel) -> LogPhiMatcher
        __init__(self, PhiMatcher<(Matcher<(Fst<(ArcTpl<(LogWeight)>)>)>)>::FST fst, 
            MatchType match_type) -> LogPhiMatcher
        """
        this = _openfst.new_LogPhiMatcher(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogPhiMatcher
    __del__ = lambda self : None;
LogPhiMatcher_swigregister = _openfst.LogPhiMatcher_swigregister
LogPhiMatcher_swigregister(LogPhiMatcher)

class StdPhiComposeOptions(_object):
    """Proxy of C++ ComposeFstOptions<(StdArc,StdPhiMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdPhiComposeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdPhiComposeOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["gc"] = _openfst.StdPhiComposeOptions_gc_set
    __swig_getmethods__["gc"] = _openfst.StdPhiComposeOptions_gc_get
    if _newclass:gc = _swig_property(_openfst.StdPhiComposeOptions_gc_get, _openfst.StdPhiComposeOptions_gc_set)
    __swig_setmethods__["gc_limit"] = _openfst.StdPhiComposeOptions_gc_limit_set
    __swig_getmethods__["gc_limit"] = _openfst.StdPhiComposeOptions_gc_limit_get
    if _newclass:gc_limit = _swig_property(_openfst.StdPhiComposeOptions_gc_limit_get, _openfst.StdPhiComposeOptions_gc_limit_set)
    __swig_setmethods__["matcher1"] = _openfst.StdPhiComposeOptions_matcher1_set
    __swig_getmethods__["matcher1"] = _openfst.StdPhiComposeOptions_matcher1_get
    if _newclass:matcher1 = _swig_property(_openfst.StdPhiComposeOptions_matcher1_get, _openfst.StdPhiComposeOptions_matcher1_set)
    __swig_setmethods__["matcher2"] = _openfst.StdPhiComposeOptions_matcher2_set
    __swig_getmethods__["matcher2"] = _openfst.StdPhiComposeOptions_matcher2_get
    if _newclass:matcher2 = _swig_property(_openfst.StdPhiComposeOptions_matcher2_get, _openfst.StdPhiComposeOptions_matcher2_set)
    __swig_setmethods__["filter"] = _openfst.StdPhiComposeOptions_filter_set
    __swig_getmethods__["filter"] = _openfst.StdPhiComposeOptions_filter_get
    if _newclass:filter = _swig_property(_openfst.StdPhiComposeOptions_filter_get, _openfst.StdPhiComposeOptions_filter_set)
    def __init__(self): 
        """__init__(self) -> StdPhiComposeOptions"""
        this = _openfst.new_StdPhiComposeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_StdPhiComposeOptions
    __del__ = lambda self : None;
StdPhiComposeOptions_swigregister = _openfst.StdPhiComposeOptions_swigregister
StdPhiComposeOptions_swigregister(StdPhiComposeOptions)

class LogPhiComposeOptions(_object):
    """Proxy of C++ ComposeFstOptions<(StdArc,LogPhiMatcher)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogPhiComposeOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LogPhiComposeOptions, name)
    __repr__ = _swig_repr
    __swig_setmethods__["gc"] = _openfst.LogPhiComposeOptions_gc_set
    __swig_getmethods__["gc"] = _openfst.LogPhiComposeOptions_gc_get
    if _newclass:gc = _swig_property(_openfst.LogPhiComposeOptions_gc_get, _openfst.LogPhiComposeOptions_gc_set)
    __swig_setmethods__["gc_limit"] = _openfst.LogPhiComposeOptions_gc_limit_set
    __swig_getmethods__["gc_limit"] = _openfst.LogPhiComposeOptions_gc_limit_get
    if _newclass:gc_limit = _swig_property(_openfst.LogPhiComposeOptions_gc_limit_get, _openfst.LogPhiComposeOptions_gc_limit_set)
    __swig_setmethods__["matcher1"] = _openfst.LogPhiComposeOptions_matcher1_set
    __swig_getmethods__["matcher1"] = _openfst.LogPhiComposeOptions_matcher1_get
    if _newclass:matcher1 = _swig_property(_openfst.LogPhiComposeOptions_matcher1_get, _openfst.LogPhiComposeOptions_matcher1_set)
    __swig_setmethods__["matcher2"] = _openfst.LogPhiComposeOptions_matcher2_set
    __swig_getmethods__["matcher2"] = _openfst.LogPhiComposeOptions_matcher2_get
    if _newclass:matcher2 = _swig_property(_openfst.LogPhiComposeOptions_matcher2_get, _openfst.LogPhiComposeOptions_matcher2_set)
    __swig_setmethods__["filter"] = _openfst.LogPhiComposeOptions_filter_set
    __swig_getmethods__["filter"] = _openfst.LogPhiComposeOptions_filter_get
    if _newclass:filter = _swig_property(_openfst.LogPhiComposeOptions_filter_get, _openfst.LogPhiComposeOptions_filter_set)
    def __init__(self): 
        """__init__(self) -> LogPhiComposeOptions"""
        this = _openfst.new_LogPhiComposeOptions()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _openfst.delete_LogPhiComposeOptions
    __del__ = lambda self : None;
LogPhiComposeOptions_swigregister = _openfst.LogPhiComposeOptions_swigregister
LogPhiComposeOptions_swigregister(LogPhiComposeOptions)


def Push(*args):
  """Push(StdMutableFst fst)"""
  return _openfst.Push(*args)
class BeamPrune(_object):
    """Proxy of C++ BeamPrune class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BeamPrune, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BeamPrune, name)
    __repr__ = _swig_repr
    __swig_setmethods__["inputSizeBound"] = _openfst.BeamPrune_inputSizeBound_set
    __swig_getmethods__["inputSizeBound"] = _openfst.BeamPrune_inputSizeBound_get
    if _newclass:inputSizeBound = _swig_property(_openfst.BeamPrune_inputSizeBound_get, _openfst.BeamPrune_inputSizeBound_set)
    __swig_setmethods__["alignSymbol"] = _openfst.BeamPrune_alignSymbol_set
    __swig_getmethods__["alignSymbol"] = _openfst.BeamPrune_alignSymbol_get
    if _newclass:alignSymbol = _swig_property(_openfst.BeamPrune_alignSymbol_get, _openfst.BeamPrune_alignSymbol_set)
    __swig_setmethods__["bound"] = _openfst.BeamPrune_bound_set
    __swig_getmethods__["bound"] = _openfst.BeamPrune_bound_get
    if _newclass:bound = _swig_property(_openfst.BeamPrune_bound_get, _openfst.BeamPrune_bound_set)
    __swig_setmethods__["symbolBound"] = _openfst.BeamPrune_symbolBound_set
    __swig_getmethods__["symbolBound"] = _openfst.BeamPrune_symbolBound_get
    if _newclass:symbolBound = _swig_property(_openfst.BeamPrune_symbolBound_get, _openfst.BeamPrune_symbolBound_set)
    __swig_setmethods__["previous"] = _openfst.BeamPrune_previous_set
    __swig_getmethods__["previous"] = _openfst.BeamPrune_previous_get
    if _newclass:previous = _swig_property(_openfst.BeamPrune_previous_get, _openfst.BeamPrune_previous_set)
    __swig_setmethods__["previous_state"] = _openfst.BeamPrune_previous_state_set
    __swig_getmethods__["previous_state"] = _openfst.BeamPrune_previous_state_get
    if _newclass:previous_state = _swig_property(_openfst.BeamPrune_previous_state_get, _openfst.BeamPrune_previous_state_set)
    __swig_setmethods__["distances"] = _openfst.BeamPrune_distances_set
    __swig_getmethods__["distances"] = _openfst.BeamPrune_distances_get
    if _newclass:distances = _swig_property(_openfst.BeamPrune_distances_get, _openfst.BeamPrune_distances_set)
    __swig_setmethods__["heuristic_chart"] = _openfst.BeamPrune_heuristic_chart_set
    __swig_getmethods__["heuristic_chart"] = _openfst.BeamPrune_heuristic_chart_get
    if _newclass:heuristic_chart = _swig_property(_openfst.BeamPrune_heuristic_chart_get, _openfst.BeamPrune_heuristic_chart_set)
    __swig_setmethods__["steps_chart"] = _openfst.BeamPrune_steps_chart_set
    __swig_getmethods__["steps_chart"] = _openfst.BeamPrune_steps_chart_get
    if _newclass:steps_chart = _swig_property(_openfst.BeamPrune_steps_chart_get, _openfst.BeamPrune_steps_chart_set)
    __swig_setmethods__["heuristic"] = _openfst.BeamPrune_heuristic_set
    __swig_getmethods__["heuristic"] = _openfst.BeamPrune_heuristic_get
    if _newclass:heuristic = _swig_property(_openfst.BeamPrune_heuristic_get, _openfst.BeamPrune_heuristic_set)
    def __init__(self, *args): 
        """
        __init__(self, int sizeBound, int output_bound, long long align_symbol, 
            int nt_symbol_bound) -> BeamPrune
        """
        this = _openfst.new_BeamPrune(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetHeuristicBack(self, *args):
        """
        SetHeuristicBack(self, FloatVector distances, IntVector reached, IntVector topo, 
            IntVector state_symbol)
        """
        return _openfst.BeamPrune_SetHeuristicBack(self, *args)

    def SetHeuristic(self, *args):
        """SetHeuristic(self, IntVector step, IntVector symbol, FloatVector back)"""
        return _openfst.BeamPrune_SetHeuristic(self, *args)

    def BeamPruneAndOrder(self, *args):
        """
        BeamPruneAndOrder(self, StdFst fst, StdMutableFst out, float beamWidth, int beamCard, 
            IntVector symbol, FloatVector weight, 
            IntVector path, FloatVector float_distances, 
            IntVector reached, bool return_distances) -> float
        """
        return _openfst.BeamPrune_BeamPruneAndOrder(self, *args)

    def AStar(self, *args):
        """
        AStar(self, StdFst fst, IntVector symbol, FloatVector weight, IntVector path, 
            FloatVector float_distances, IntVector reached) -> int
        """
        return _openfst.BeamPrune_AStar(self, *args)

    __swig_destroy__ = _openfst.delete_BeamPrune
    __del__ = lambda self : None;
BeamPrune_swigregister = _openfst.BeamPrune_swigregister
BeamPrune_swigregister(BeamPrune)

def Compose(*args):
  """
    Compose(StdFst fst1, StdFst fst2, StdMutableFst result)
    Compose(LogFst fst1, LogFst fst2, LogMutableFst result)

    Compose two FSTs placing the result in a newly initialized FST.
    """
  return _openfst.Compose(*args)

def Connect(*args):
  """
    Connect(StdMutableFst fst)
    Connect(LogMutableFst fst)

    Connect an FST.
    """
  return _openfst.Connect(*args)

def Determinize(*args):
  """
    Determinize(StdFst _in, StdMutableFst out)
    Determinize(LogFst _in, LogMutableFst out)

    Determinize an FST, placing the result in a newly initialize FST.
    """
  return _openfst.Determinize(*args)

def Difference(*args):
  """
    Difference(StdFst fst, StdFst fst2, StdMutableFst out)
    Difference(LogFst fst, LogFst fst2, LogMutableFst out)

    Take the difference between two FSTs, placing the result in a
    newly initialized FST.
    """
  return _openfst.Difference(*args)

def Intersect(*args):
  """
    Intersect(StdFst fst, StdFst fst2, StdMutableFst out)
    Intersect(LogFst fst, LogFst fst2, LogMutableFst out)

    Intersect two FSTs, placing the result in a
    newly initialized FST.
    """
  return _openfst.Intersect(*args)

def Invert(*args):
  """
    Invert(StdMutableFst fst)
    Invert(LogMutableFst fst)

    Invert an FST.
    """
  return _openfst.Invert(*args)

def Minimize(*args):
  """
    Minimize(StdMutableFst fst)
    Minimize(LogMutableFst fst)

    Minimize an FST.
    """
  return _openfst.Minimize(*args)

def Prune(*args):
  """
    Prune(StdMutableFst fst, float threshold)
    Prune(LogMutableFst fst, float threshold)

    Prune an FST, removing all arcs above threshold
    """
  return _openfst.Prune(*args)

def RandEquivalent(*args):
  """
    RandEquivalent(StdFst fst, StdFst fst2, int n) -> bool
    RandEquivalent(LogFst fst, LogFst fst2, int n) -> bool

    ??
    """
  return _openfst.RandEquivalent(*args)

def RandGen(*args):
  """
    RandGen(StdFst fst, StdMutableFst out)
    RandGen(LogFst fst, LogMutableFst out)

    ??
    """
  return _openfst.RandGen(*args)

def Reverse(*args):
  """
    Reverse(StdFst fst, StdMutableFst out)
    Reverse(LogFst fst, LogMutableFst out)

    Reverse an FST, placing result in a newly initialized FST.
    """
  return _openfst.Reverse(*args)

def RmEpsilon(*args):
  """
    RmEpsilon(StdMutableFst out)
    RmEpsilon(LogMutableFst out)

    Remove epsilon transitions from an FST.
    """
  return _openfst.RmEpsilon(*args)

def ShortestPath(*args):
  """
    ShortestPath(StdFst fst, StdMutableFst out, int n)
    ShortestPath(LogFst fst, LogMutableFst out, int n)

    Find N shortest paths in an FST placing results in a newly initialized FST.
    """
  return _openfst.ShortestPath(*args)

def TopSort(*args):
  """
    TopSort(StdMutableFst fst)
    TopSort(LogMutableFst fst)

    Topologically sort an FST.
    """
  return _openfst.TopSort(*args)

def Union(*args):
  """
    Union(StdMutableFst out, StdFst fst)
    Union(LogMutableFst out, LogFst fst)

    Take the union of two FSTs, placing the result in the first argument.
    """
  return _openfst.Union(*args)

def Verify(*args):
  """
    Verify(StdFst fst)
    Verify(LogFst fst)

    Verify an FST.
    """
  return _openfst.Verify(*args)


def ShortestDistance(*args):
  """ShortestDistance(StdFst fst, FloatVector ret, bool reverse)"""
  return _openfst.ShortestDistance(*args)

def ShortestPathDijkstra(*args):
  """ShortestPathDijkstra(StdFst fst, StdMutableFst out, int n)"""
  return _openfst.ShortestPathDijkstra(*args)

def RemoveWeight(*args):
  """RemoveWeight(StdFst fst, StdMutableFst out)"""
  return _openfst.RemoveWeight(*args)

def ShortestPathViterbi(*args):
  """ShortestPathViterbi(StdFst fst, StdMutableFst out, int n)"""
  return _openfst.ShortestPathViterbi(*args)

def Read(*args):
  """
    Read(char s) -> StdVectorFst

    Convenience function to read a StdVectorFst from a file.
    """
  return _openfst.Read(*args)


def GetString(*args):
  """
    GetString(StdMutableFst fst, int which = 0) -> char
    GetString(StdMutableFst fst) -> char
    GetString(LogMutableFst fst, int which = 0) -> char
    GetString(LogMutableFst fst) -> char

    Get string starting at given state.
    """
  return _openfst.GetString(*args)

def WGetString(*args):
  """
    WGetString(StdMutableFst fst, int which = 0) -> wchar_t
    WGetString(StdMutableFst fst) -> wchar_t

    Get wide character string starting at given state.
    """
  return _openfst.WGetString(*args)

def ArcSortOutput(*args):
  """
    ArcSortOutput(StdMutableFst fst)
    ArcSortOutput(LogMutableFst fst)

    Sort the arcs of an FST on the output labels.
    """
  return _openfst.ArcSortOutput(*args)

def ArcSortInput(*args):
  """
    ArcSortInput(StdMutableFst fst)
    ArcSortInput(LogMutableFst fst)

    Sort the arcs of an FST on the input labels.
    """
  return _openfst.ArcSortInput(*args)

def ProjectInput(*args):
  """
    ProjectInput(StdMutableFst result)
    ProjectInput(LogMutableFst result)

    Project an FST to an FSA using the input labels.
    """
  return _openfst.ProjectInput(*args)

def ProjectOutput(*args):
  """
    ProjectOutput(StdMutableFst result)
    ProjectOutput(LogMutableFst result)

    Project an FST to an FSA using the output labels.
    """
  return _openfst.ProjectOutput(*args)

def ClosureStar(*args):
  """
    ClosureStar(StdMutableFst fst)
    ClosureStar(LogMutableFst fst)

    Perform Kleene star closure on an FST.
    """
  return _openfst.ClosureStar(*args)

def ClosurePlus(*args):
  """
    ClosurePlus(StdMutableFst fst)
    ClosurePlus(LogMutableFst fst)

    Perform plus-closure on an FST.
    """
  return _openfst.ClosurePlus(*args)

def ConcatOnto(*args):
  """
    ConcatOnto(StdMutableFst fst, StdFst fst2)
    ConcatOnto(LogMutableFst fst, LogFst fst2)

    Concatenate fst2 onto fst.
    """
  return _openfst.ConcatOnto(*args)

def ConcatOntoOther(*args):
  """
    ConcatOntoOther(StdFst fst, StdMutableFst fst2)
    ConcatOntoOther(LogFst fst, LogMutableFst fst2)

    Concatenate fst onto fst2.
    """
  return _openfst.ConcatOntoOther(*args)

def EpsNormInput(*args):
  """
    EpsNormInput(StdFst fst, StdMutableFst out)
    EpsNormInput(LogFst fst, LogMutableFst out)

    Epsilon normalize an FST on the input side.
    """
  return _openfst.EpsNormInput(*args)

def EpsNormOutput(*args):
  """
    EpsNormOutput(StdFst fst, StdMutableFst out)
    EpsNormOutput(LogFst fst, LogMutableFst out)

    Epsilon normalize an FST on the output side.
    """
  return _openfst.EpsNormOutput(*args)

def ConvertSymbols(*args):
  """
    ConvertSymbols(StdVectorFst fst, SymbolTable symtab, bool input, bool output)
    ConvertSymbols(LogVectorFst fst, SymbolTable symtab, bool input, bool output)

    Switch output and/or input symbol table and renumber arcs to match.

    Throws an exception if no mapping can be found for a symbol in C{fst}.
    @param fst: FST to modify.
    @type symtab: openfst.MutableFst
    @param symtab: New symbol table to use.
    @type symtab: openfst.SymbolTable
    @param input: Convert input symbols.
    @type input: bool
    @param output: Convert output symbols.
    @type output: bool

    """
  return _openfst.ConvertSymbols(*args)

def Copy(*args):
  """
    Copy(StdVectorFst fst) -> StdVectorFst
    Copy(LogVectorFst fst) -> LogVectorFst

    Copy an FST.
    """
  return _openfst.Copy(*args)

